# Cursor AI 代码生成指南

本文档提供了如何有效使用Cursor编辑器的AI代码生成功能来开发WebGameMulti项目的详细指南和提示模板。

## 什么是Cursor AI生成

Cursor编辑器内置强大的AI代码生成功能，可以根据提示(prompt)自动生成代码、完成功能实现或重构现有代码。相比传统的代码补全，Cursor的AI生成能够理解上下文并生成完整的代码块或文件。

## 如何激活AI生成

在Cursor编辑器中，可以通过以下方式激活AI生成：

1. **命令面板**: 按下 `Ctrl+Shift+P` (Windows) 或 `Cmd+Shift+P` (Mac)，然后输入 "Generate Code"
2. **快捷键**: 使用 `Ctrl+Enter` (Windows) 或 `Cmd+Enter` (Mac)
3. **右键菜单**: 右键点击编辑区域，选择 "AI Actions" -> "Generate Code"
4. **AI面板**: 点击编辑器右侧的AI图标，打开AI面板，输入提示

## 有效提示工程技巧

### 提示结构

有效的AI生成提示通常包含以下部分：

1. **任务描述**: 明确说明需要生成什么
2. **上下文信息**: 提供相关背景信息
3. **输入/输出规范**: 明确输入参数和预期输出
4. **示例或参考**: 提供类似代码的示例
5. **约束条件**: 说明需要遵循的规则或限制

### 提示模板化

```
生成[组件类型]，用于[功能描述]。
需要满足以下要求：
1. [要求1]
2. [要求2]
...
参考以下结构：[参考代码或结构]
必须遵循项目的编码规范，包括[具体规范]。
```

## WebGameMulti项目的AI生成提示模板

### 1. 生成React组件

```
生成一个React函数组件，名为[组件名]，用于[组件功能描述]。
组件需要接收以下props：
- [prop1]: [类型] - [描述]
- [prop2]: [类型] - [描述]
...

组件应该包含适当的PropTypes定义和默认值。
样式应使用[CSS方式]（如BEM, Tailwind等）。
确保组件遵循项目的编码规范，包括JSDoc注释和错误处理。
```

**示例**:

```
生成一个React函数组件，名为GameList，用于展示游戏列表。
组件需要接收以下props：
- games: Array - 游戏对象数组，每个对象包含id, name, description, thumbnail, tags属性
- onGameClick: Function - 点击游戏卡片时的回调函数，接收游戏id作为参数
- isLoading: Boolean - 是否正在加载数据
- error: String - 加载错误信息

组件应该包含适当的PropTypes定义和默认值。
样式应使用BEM命名规范。
确保组件遵循项目的编码规范，包括JSDoc注释和错误处理。
```

### 2. 生成自定义Hook

```
生成一个React自定义Hook，名为use[Hook名]，用于[Hook功能描述]。
Hook需要接收以下参数：
- [参数1]: [类型] - [描述]
- [参数2]: [类型] - [描述]
...

Hook应该返回：
- [返回值1]: [类型] - [描述]
- [返回值2]: [类型] - [描述]
...

包含错误处理和边缘情况处理，并确保遵循React Hook规则。
```

**示例**:

```
生成一个React自定义Hook，名为useGameData，用于从API加载游戏数据。
Hook需要接收以下参数：
- gameId: String - 可选的游戏ID，如果提供则加载单个游戏，否则加载所有游戏
- options: Object - 可选的配置项，包括刷新间隔、缓存设置等

Hook应该返回：
- games: Array/Object - 游戏数据，为数组或单个对象
- isLoading: Boolean - 是否正在加载
- error: Object - 错误信息
- refetch: Function - 手动重新获取数据的函数

包含错误处理和边缘情况处理，并确保遵循React Hook规则。
```

### 3. 生成工具函数

```
生成一个工具函数，名为[函数名]，用于[函数功能描述]。
函数需要接收以下参数：
- [参数1]: [类型] - [描述]
- [参数2]: [类型] - [描述]
...

函数应该返回：
- [返回值]: [类型] - [描述]

包含适当的错误处理和边缘情况处理，并添加JSDoc注释。
```

**示例**:

```
生成一个工具函数，名为parseGameMetadata，用于解析游戏的meta.json文件内容。
函数需要接收以下参数：
- metaData: Object - 从meta.json加载的原始数据
- gameId: String - 游戏ID
- basePath: String - 游戏资源的基础路径

函数应该返回：
- Object - 处理后的游戏元数据，包含规范化的路径和附加信息

包含适当的错误处理和边缘情况处理，并添加JSDoc注释。
```

### 4. 生成API服务

```
生成一个API服务模块，用于[功能描述]。
模块应该包含以下函数：
- [函数1]([参数]): 用于[功能描述]
- [函数2]([参数]): 用于[功能描述]
...

使用fetch API或axios进行HTTP请求，包含错误处理和响应解析。
```

**示例**:

```
生成一个API服务模块，用于处理游戏数据的获取和管理。
模块应该包含以下函数：
- getAllGames(): 获取所有游戏列表
- getGameById(id): 获取指定ID的游戏详情
- getGamesByTags(tags): 根据标签筛选游戏
- searchGames(query): 搜索游戏

使用fetch API进行HTTP请求，包含错误处理和响应解析。
实现请求缓存以提高性能。
```

### 5. 生成路由配置

```
生成React Router路由配置，用于[应用描述]。
需要包含以下路由：
- [路径1]: 对应[组件1]，用于[功能描述]
- [路径2]: 对应[组件2]，用于[功能描述]
...

包含适当的路由保护、懒加载和错误边界。
```

**示例**:

```
生成React Router v6路由配置，用于WebGameMulti游戏平台。
需要包含以下路由：
- /: 首页，显示所有游戏列表
- /games/:gameId: 游戏详情页，显示单个游戏并提供游戏iframe
- /categories/:category: 分类页，显示特定分类的游戏
- /search: 搜索结果页
- /about: 关于页面
- *: 404页面

包含适当的路由保护、懒加载和错误边界。
```

### 6. 生成完整页面组件

```
生成一个完整的React页面组件，名为[页面名]Page，用于[页面功能描述]。
页面需要包含以下功能：
- [功能1]
- [功能2]
...

使用以下组件：
- [组件1]: 用于[功能描述]
- [组件2]: 用于[功能描述]
...

包含加载状态、错误处理和用户反馈。
遵循项目的页面结构和样式规范。
```

**示例**:

```
生成一个完整的React页面组件，名为GameDetailPage，用于显示游戏详情和提供游戏试玩功能。
页面需要包含以下功能：
- 显示游戏标题、描述、标签和缩略图
- 显示游戏控制说明
- 在iframe中嵌入游戏
- 提供返回按钮
- 适配移动端和桌面端布局

使用以下组件：
- GameHeader: 显示游戏标题和返回按钮
- GameInfo: 显示游戏详细信息
- GameFrame: 封装游戏iframe
- LoadingSpinner: 显示加载状态

包含加载状态、错误处理和用户反馈。
遵循项目的页面结构和BEM样式规范。
```

### 7. 生成测试代码

```
生成针对[组件/函数名]的Jest测试代码。
测试应该覆盖以下场景：
- [场景1]
- [场景2]
...

使用React Testing Library和Jest进行测试。
包含合适的模拟(mock)和断言。
```

**示例**:

```
生成针对GameCard组件的Jest测试代码。
测试应该覆盖以下场景：
- 正确渲染游戏名称、描述和缩略图
- 点击卡片时调用onClick回调
- 正确处理缺少的属性（使用默认值）
- 标签正确渲染和溢出处理

使用React Testing Library和Jest进行测试。
包含合适的模拟(mock)和断言。
```

## 使用AI生成的最佳实践

### 1. 先描述后生成

在开始生成代码前，先用注释描述你想要实现的功能，这样AI可以更好地理解你的意图：

```javascript
// 创建一个游戏卡片网格组件，以响应式网格布局显示多个游戏卡片
// 需要处理不同屏幕尺寸，在小屏幕上每行显示1个，中等屏幕2个，大屏幕3个
// 支持通过props传入游戏列表，并支持加载状态和错误处理
```

### 2. 逐步迭代

对于复杂功能，采用逐步迭代的方式：

1. 先生成基本骨架
2. 审查并调整
3. 继续生成更多细节
4. 重复直至完成

### 3. 提供上下文

将相关的导入、类型定义或相关组件的片段粘贴到提示中，帮助AI理解上下文：

```javascript
// 以下是GameCard组件的代码:
function GameCard({ name, description, thumbnail, onClick }) {
  // ... 组件代码
}

// 现在，创建一个GameGrid组件来显示多个GameCard
```

### 4. 指定编码风格

明确指定你希望使用的编码风格和模式：

```
生成一个React组件，使用函数组件和Hooks，遵循项目的BEM命名规范，并使用JSDoc注释。
```

## AI生成后的检查清单

每次使用AI生成代码后，请检查以下方面：

1. **功能完整性**: 代码是否实现了所有要求的功能？
2. **错误处理**: 是否处理了可能的错误和边缘情况？
3. **性能考虑**: 代码是否有性能问题？
4. **安全性**: 是否存在安全隐患？
5. **可维护性**: 代码是否易于理解和维护？
6. **编码规范**: 是否符合项目的编码规范？
7. **依赖项**: 是否正确处理了所有依赖项？

## 示例用例

### 示例1: 生成游戏卡片组件

**提示**:
```
生成一个React函数组件，名为GameCard，用于显示游戏信息卡片。
组件需要接收以下props：
- game: Object - 包含id, name, description, thumbnail, tags属性的游戏对象
- onClick: Function - 点击卡片的回调函数

卡片设计应包含：
- 顶部显示游戏缩略图
- 中间显示游戏名称（粗体）
- 下方显示游戏简短描述（最多2行，溢出显示省略号）
- 底部显示游戏标签（水平排列，可换行）

样式使用BEM命名规范，响应式设计适配不同屏幕尺寸。
包含鼠标悬停效果，悬停时轻微上浮并增加阴影。
确保添加适当的PropTypes验证和JSDoc注释。
```

### 示例2: 生成游戏加载Hook

**提示**:
```
创建一个名为useGameLoader的自定义React Hook，用于从games目录加载游戏数据。
Hook需要：
1. 在组件挂载时自动扫描games目录下的所有游戏文件夹
2. 读取每个游戏文件夹中的meta.json文件获取游戏信息
3. 返回格式化后的游戏列表、加载状态和错误信息
4. 提供按标签筛选游戏的功能
5. 支持搜索功能（根据游戏名称和描述）

返回的数据结构应包括：
- games: 游戏对象数组
- isLoading: 布尔值表示加载状态
- error: 错误信息
- filterByTag: 按标签筛选的函数
- searchGames: 搜索游戏的函数

实现中应考虑错误处理、缓存和性能优化。
```

### 示例3: 生成游戏详情页

**提示**:
```
创建一个完整的React页面组件GameDetailPage，用于显示游戏详情并提供游戏试玩功能。
页面应从URL参数中获取游戏ID，然后加载相应游戏的信息。

页面布局：
- 顶部：导航栏，包含返回按钮和游戏名称
- 主体部分分为两列（在移动设备上堆叠显示）：
  - 左侧：游戏信息，包括名称、描述、标签、作者、控制说明等
  - 右侧：游戏iframe，自适应容器大小

功能要求：
- 加载时显示加载指示器
- 处理游戏不存在的情况
- iframe加载完成前显示加载动画
- 支持全屏模式
- 记住滚动位置

使用React Router进行导航，使用自定义Hook获取游戏数据。
遵循项目的编码规范和样式指南。
```

## 使用AI改进现有代码

除了生成新代码，Cursor的AI还可以帮助改进现有代码：

### 代码重构

```
重构以下代码，提高可读性和性能：

[粘贴需要重构的代码]

具体改进点：
1. 提取重复逻辑为独立函数
2. 使用更现代的JavaScript语法
3. 优化性能，减少不必要的计算
4. 改进错误处理
```

### 添加注释

```
为以下代码添加详细的JSDoc注释：

[粘贴需要添加注释的代码]
```

### 添加测试

```
为以下函数/组件生成Jest测试：

[粘贴需要测试的代码]

测试应覆盖主要功能和边缘情况。
```

## 结论

有效使用Cursor的AI代码生成功能可以显著提高开发效率，减少重复工作。关键是提供清晰、详细的提示，并在生成后仔细审查代码，确保其符合项目要求和最佳实践。

随着使用经验的积累，你可以开发出更适合自己工作流程的提示模板，进一步提高AI生成的准确性和实用性。 